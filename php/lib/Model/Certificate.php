<?php
/**
 * Certificate
 *
 * PHP version 5
 *
 * @category Class
 * @package  Ory\Hydra\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * ORY Hydra
 *
 * Welcome to the ORY Hydra HTTP API documentation. You will find documentation for all HTTP APIs here.
 *
 * The version of the OpenAPI document: latest
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.2.2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Ory\Hydra\Client\Model;

use \ArrayAccess;
use \Ory\Hydra\Client\ObjectSerializer;

/**
 * Certificate Class Doc Comment
 *
 * @category Class
 * @package  Ory\Hydra\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Certificate implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Certificate';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'authorityKeyId' => 'int[]',
        'basicConstraintsValid' => 'bool',
        'cRLDistributionPoints' => 'string[]',
        'dNSNames' => 'string[]',
        'emailAddresses' => 'string[]',
        'excludedDNSDomains' => 'string[]',
        'excludedEmailAddresses' => 'string[]',
        'excludedIPRanges' => '\Ory\Hydra\Client\Model\IPNet[]',
        'excludedURIDomains' => 'string[]',
        'extKeyUsage' => 'int[]',
        'extensions' => '\Ory\Hydra\Client\Model\Extension[]',
        'extraExtensions' => '\Ory\Hydra\Client\Model\Extension[]',
        'iPAddresses' => '\Ory\Hydra\Client\Model\array[]',
        'isCA' => 'bool',
        'issuer' => '\Ory\Hydra\Client\Model\Name',
        'issuingCertificateURL' => 'string[]',
        'keyUsage' => 'int',
        'maxPathLen' => 'int',
        'maxPathLenZero' => 'bool',
        'notBefore' => '\DateTime',
        'oCSPServer' => 'string[]',
        'permittedDNSDomains' => 'string[]',
        'permittedDNSDomainsCritical' => 'bool',
        'permittedEmailAddresses' => 'string[]',
        'permittedIPRanges' => '\Ory\Hydra\Client\Model\IPNet[]',
        'permittedURIDomains' => 'string[]',
        'policyIdentifiers' => '\Ory\Hydra\Client\Model\array[]',
        'publicKey' => 'object',
        'publicKeyAlgorithm' => 'int',
        'raw' => 'int[]',
        'rawIssuer' => 'int[]',
        'rawSubject' => 'int[]',
        'rawSubjectPublicKeyInfo' => 'int[]',
        'rawTBSCertificate' => 'int[]',
        'serialNumber' => 'object',
        'signature' => 'int[]',
        'signatureAlgorithm' => 'int',
        'subject' => '\Ory\Hydra\Client\Model\Name',
        'subjectKeyId' => 'int[]',
        'uRIs' => '\Ory\Hydra\Client\Model\URL[]',
        'unhandledCriticalExtensions' => '\Ory\Hydra\Client\Model\array[]',
        'unknownExtKeyUsage' => '\Ory\Hydra\Client\Model\array[]',
        'version' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'authorityKeyId' => 'uint8',
        'basicConstraintsValid' => null,
        'cRLDistributionPoints' => null,
        'dNSNames' => null,
        'emailAddresses' => null,
        'excludedDNSDomains' => null,
        'excludedEmailAddresses' => null,
        'excludedIPRanges' => null,
        'excludedURIDomains' => null,
        'extKeyUsage' => 'int64',
        'extensions' => null,
        'extraExtensions' => null,
        'iPAddresses' => 'uint8',
        'isCA' => null,
        'issuer' => null,
        'issuingCertificateURL' => null,
        'keyUsage' => 'int64',
        'maxPathLen' => 'int64',
        'maxPathLenZero' => null,
        'notBefore' => 'date-time',
        'oCSPServer' => null,
        'permittedDNSDomains' => null,
        'permittedDNSDomainsCritical' => null,
        'permittedEmailAddresses' => null,
        'permittedIPRanges' => null,
        'permittedURIDomains' => null,
        'policyIdentifiers' => 'int64',
        'publicKey' => null,
        'publicKeyAlgorithm' => 'int64',
        'raw' => 'uint8',
        'rawIssuer' => 'uint8',
        'rawSubject' => 'uint8',
        'rawSubjectPublicKeyInfo' => 'uint8',
        'rawTBSCertificate' => 'uint8',
        'serialNumber' => null,
        'signature' => 'uint8',
        'signatureAlgorithm' => 'int64',
        'subject' => null,
        'subjectKeyId' => 'uint8',
        'uRIs' => null,
        'unhandledCriticalExtensions' => 'int64',
        'unknownExtKeyUsage' => 'int64',
        'version' => 'int64'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'authorityKeyId' => 'AuthorityKeyId',
        'basicConstraintsValid' => 'BasicConstraintsValid',
        'cRLDistributionPoints' => 'CRLDistributionPoints',
        'dNSNames' => 'DNSNames',
        'emailAddresses' => 'EmailAddresses',
        'excludedDNSDomains' => 'ExcludedDNSDomains',
        'excludedEmailAddresses' => 'ExcludedEmailAddresses',
        'excludedIPRanges' => 'ExcludedIPRanges',
        'excludedURIDomains' => 'ExcludedURIDomains',
        'extKeyUsage' => 'ExtKeyUsage',
        'extensions' => 'Extensions',
        'extraExtensions' => 'ExtraExtensions',
        'iPAddresses' => 'IPAddresses',
        'isCA' => 'IsCA',
        'issuer' => 'Issuer',
        'issuingCertificateURL' => 'IssuingCertificateURL',
        'keyUsage' => 'KeyUsage',
        'maxPathLen' => 'MaxPathLen',
        'maxPathLenZero' => 'MaxPathLenZero',
        'notBefore' => 'NotBefore',
        'oCSPServer' => 'OCSPServer',
        'permittedDNSDomains' => 'PermittedDNSDomains',
        'permittedDNSDomainsCritical' => 'PermittedDNSDomainsCritical',
        'permittedEmailAddresses' => 'PermittedEmailAddresses',
        'permittedIPRanges' => 'PermittedIPRanges',
        'permittedURIDomains' => 'PermittedURIDomains',
        'policyIdentifiers' => 'PolicyIdentifiers',
        'publicKey' => 'PublicKey',
        'publicKeyAlgorithm' => 'PublicKeyAlgorithm',
        'raw' => 'Raw',
        'rawIssuer' => 'RawIssuer',
        'rawSubject' => 'RawSubject',
        'rawSubjectPublicKeyInfo' => 'RawSubjectPublicKeyInfo',
        'rawTBSCertificate' => 'RawTBSCertificate',
        'serialNumber' => 'SerialNumber',
        'signature' => 'Signature',
        'signatureAlgorithm' => 'SignatureAlgorithm',
        'subject' => 'Subject',
        'subjectKeyId' => 'SubjectKeyId',
        'uRIs' => 'URIs',
        'unhandledCriticalExtensions' => 'UnhandledCriticalExtensions',
        'unknownExtKeyUsage' => 'UnknownExtKeyUsage',
        'version' => 'Version'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'authorityKeyId' => 'setAuthorityKeyId',
        'basicConstraintsValid' => 'setBasicConstraintsValid',
        'cRLDistributionPoints' => 'setCRLDistributionPoints',
        'dNSNames' => 'setDNSNames',
        'emailAddresses' => 'setEmailAddresses',
        'excludedDNSDomains' => 'setExcludedDNSDomains',
        'excludedEmailAddresses' => 'setExcludedEmailAddresses',
        'excludedIPRanges' => 'setExcludedIPRanges',
        'excludedURIDomains' => 'setExcludedURIDomains',
        'extKeyUsage' => 'setExtKeyUsage',
        'extensions' => 'setExtensions',
        'extraExtensions' => 'setExtraExtensions',
        'iPAddresses' => 'setIPAddresses',
        'isCA' => 'setIsCA',
        'issuer' => 'setIssuer',
        'issuingCertificateURL' => 'setIssuingCertificateURL',
        'keyUsage' => 'setKeyUsage',
        'maxPathLen' => 'setMaxPathLen',
        'maxPathLenZero' => 'setMaxPathLenZero',
        'notBefore' => 'setNotBefore',
        'oCSPServer' => 'setOCSPServer',
        'permittedDNSDomains' => 'setPermittedDNSDomains',
        'permittedDNSDomainsCritical' => 'setPermittedDNSDomainsCritical',
        'permittedEmailAddresses' => 'setPermittedEmailAddresses',
        'permittedIPRanges' => 'setPermittedIPRanges',
        'permittedURIDomains' => 'setPermittedURIDomains',
        'policyIdentifiers' => 'setPolicyIdentifiers',
        'publicKey' => 'setPublicKey',
        'publicKeyAlgorithm' => 'setPublicKeyAlgorithm',
        'raw' => 'setRaw',
        'rawIssuer' => 'setRawIssuer',
        'rawSubject' => 'setRawSubject',
        'rawSubjectPublicKeyInfo' => 'setRawSubjectPublicKeyInfo',
        'rawTBSCertificate' => 'setRawTBSCertificate',
        'serialNumber' => 'setSerialNumber',
        'signature' => 'setSignature',
        'signatureAlgorithm' => 'setSignatureAlgorithm',
        'subject' => 'setSubject',
        'subjectKeyId' => 'setSubjectKeyId',
        'uRIs' => 'setURIs',
        'unhandledCriticalExtensions' => 'setUnhandledCriticalExtensions',
        'unknownExtKeyUsage' => 'setUnknownExtKeyUsage',
        'version' => 'setVersion'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'authorityKeyId' => 'getAuthorityKeyId',
        'basicConstraintsValid' => 'getBasicConstraintsValid',
        'cRLDistributionPoints' => 'getCRLDistributionPoints',
        'dNSNames' => 'getDNSNames',
        'emailAddresses' => 'getEmailAddresses',
        'excludedDNSDomains' => 'getExcludedDNSDomains',
        'excludedEmailAddresses' => 'getExcludedEmailAddresses',
        'excludedIPRanges' => 'getExcludedIPRanges',
        'excludedURIDomains' => 'getExcludedURIDomains',
        'extKeyUsage' => 'getExtKeyUsage',
        'extensions' => 'getExtensions',
        'extraExtensions' => 'getExtraExtensions',
        'iPAddresses' => 'getIPAddresses',
        'isCA' => 'getIsCA',
        'issuer' => 'getIssuer',
        'issuingCertificateURL' => 'getIssuingCertificateURL',
        'keyUsage' => 'getKeyUsage',
        'maxPathLen' => 'getMaxPathLen',
        'maxPathLenZero' => 'getMaxPathLenZero',
        'notBefore' => 'getNotBefore',
        'oCSPServer' => 'getOCSPServer',
        'permittedDNSDomains' => 'getPermittedDNSDomains',
        'permittedDNSDomainsCritical' => 'getPermittedDNSDomainsCritical',
        'permittedEmailAddresses' => 'getPermittedEmailAddresses',
        'permittedIPRanges' => 'getPermittedIPRanges',
        'permittedURIDomains' => 'getPermittedURIDomains',
        'policyIdentifiers' => 'getPolicyIdentifiers',
        'publicKey' => 'getPublicKey',
        'publicKeyAlgorithm' => 'getPublicKeyAlgorithm',
        'raw' => 'getRaw',
        'rawIssuer' => 'getRawIssuer',
        'rawSubject' => 'getRawSubject',
        'rawSubjectPublicKeyInfo' => 'getRawSubjectPublicKeyInfo',
        'rawTBSCertificate' => 'getRawTBSCertificate',
        'serialNumber' => 'getSerialNumber',
        'signature' => 'getSignature',
        'signatureAlgorithm' => 'getSignatureAlgorithm',
        'subject' => 'getSubject',
        'subjectKeyId' => 'getSubjectKeyId',
        'uRIs' => 'getURIs',
        'unhandledCriticalExtensions' => 'getUnhandledCriticalExtensions',
        'unknownExtKeyUsage' => 'getUnknownExtKeyUsage',
        'version' => 'getVersion'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['authorityKeyId'] = isset($data['authorityKeyId']) ? $data['authorityKeyId'] : null;
        $this->container['basicConstraintsValid'] = isset($data['basicConstraintsValid']) ? $data['basicConstraintsValid'] : null;
        $this->container['cRLDistributionPoints'] = isset($data['cRLDistributionPoints']) ? $data['cRLDistributionPoints'] : null;
        $this->container['dNSNames'] = isset($data['dNSNames']) ? $data['dNSNames'] : null;
        $this->container['emailAddresses'] = isset($data['emailAddresses']) ? $data['emailAddresses'] : null;
        $this->container['excludedDNSDomains'] = isset($data['excludedDNSDomains']) ? $data['excludedDNSDomains'] : null;
        $this->container['excludedEmailAddresses'] = isset($data['excludedEmailAddresses']) ? $data['excludedEmailAddresses'] : null;
        $this->container['excludedIPRanges'] = isset($data['excludedIPRanges']) ? $data['excludedIPRanges'] : null;
        $this->container['excludedURIDomains'] = isset($data['excludedURIDomains']) ? $data['excludedURIDomains'] : null;
        $this->container['extKeyUsage'] = isset($data['extKeyUsage']) ? $data['extKeyUsage'] : null;
        $this->container['extensions'] = isset($data['extensions']) ? $data['extensions'] : null;
        $this->container['extraExtensions'] = isset($data['extraExtensions']) ? $data['extraExtensions'] : null;
        $this->container['iPAddresses'] = isset($data['iPAddresses']) ? $data['iPAddresses'] : null;
        $this->container['isCA'] = isset($data['isCA']) ? $data['isCA'] : null;
        $this->container['issuer'] = isset($data['issuer']) ? $data['issuer'] : null;
        $this->container['issuingCertificateURL'] = isset($data['issuingCertificateURL']) ? $data['issuingCertificateURL'] : null;
        $this->container['keyUsage'] = isset($data['keyUsage']) ? $data['keyUsage'] : null;
        $this->container['maxPathLen'] = isset($data['maxPathLen']) ? $data['maxPathLen'] : null;
        $this->container['maxPathLenZero'] = isset($data['maxPathLenZero']) ? $data['maxPathLenZero'] : null;
        $this->container['notBefore'] = isset($data['notBefore']) ? $data['notBefore'] : null;
        $this->container['oCSPServer'] = isset($data['oCSPServer']) ? $data['oCSPServer'] : null;
        $this->container['permittedDNSDomains'] = isset($data['permittedDNSDomains']) ? $data['permittedDNSDomains'] : null;
        $this->container['permittedDNSDomainsCritical'] = isset($data['permittedDNSDomainsCritical']) ? $data['permittedDNSDomainsCritical'] : null;
        $this->container['permittedEmailAddresses'] = isset($data['permittedEmailAddresses']) ? $data['permittedEmailAddresses'] : null;
        $this->container['permittedIPRanges'] = isset($data['permittedIPRanges']) ? $data['permittedIPRanges'] : null;
        $this->container['permittedURIDomains'] = isset($data['permittedURIDomains']) ? $data['permittedURIDomains'] : null;
        $this->container['policyIdentifiers'] = isset($data['policyIdentifiers']) ? $data['policyIdentifiers'] : null;
        $this->container['publicKey'] = isset($data['publicKey']) ? $data['publicKey'] : null;
        $this->container['publicKeyAlgorithm'] = isset($data['publicKeyAlgorithm']) ? $data['publicKeyAlgorithm'] : null;
        $this->container['raw'] = isset($data['raw']) ? $data['raw'] : null;
        $this->container['rawIssuer'] = isset($data['rawIssuer']) ? $data['rawIssuer'] : null;
        $this->container['rawSubject'] = isset($data['rawSubject']) ? $data['rawSubject'] : null;
        $this->container['rawSubjectPublicKeyInfo'] = isset($data['rawSubjectPublicKeyInfo']) ? $data['rawSubjectPublicKeyInfo'] : null;
        $this->container['rawTBSCertificate'] = isset($data['rawTBSCertificate']) ? $data['rawTBSCertificate'] : null;
        $this->container['serialNumber'] = isset($data['serialNumber']) ? $data['serialNumber'] : null;
        $this->container['signature'] = isset($data['signature']) ? $data['signature'] : null;
        $this->container['signatureAlgorithm'] = isset($data['signatureAlgorithm']) ? $data['signatureAlgorithm'] : null;
        $this->container['subject'] = isset($data['subject']) ? $data['subject'] : null;
        $this->container['subjectKeyId'] = isset($data['subjectKeyId']) ? $data['subjectKeyId'] : null;
        $this->container['uRIs'] = isset($data['uRIs']) ? $data['uRIs'] : null;
        $this->container['unhandledCriticalExtensions'] = isset($data['unhandledCriticalExtensions']) ? $data['unhandledCriticalExtensions'] : null;
        $this->container['unknownExtKeyUsage'] = isset($data['unknownExtKeyUsage']) ? $data['unknownExtKeyUsage'] : null;
        $this->container['version'] = isset($data['version']) ? $data['version'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets authorityKeyId
     *
     * @return int[]|null
     */
    public function getAuthorityKeyId()
    {
        return $this->container['authorityKeyId'];
    }

    /**
     * Sets authorityKeyId
     *
     * @param int[]|null $authorityKeyId authority key Id
     *
     * @return $this
     */
    public function setAuthorityKeyId($authorityKeyId)
    {
        $this->container['authorityKeyId'] = $authorityKeyId;

        return $this;
    }

    /**
     * Gets basicConstraintsValid
     *
     * @return bool|null
     */
    public function getBasicConstraintsValid()
    {
        return $this->container['basicConstraintsValid'];
    }

    /**
     * Sets basicConstraintsValid
     *
     * @param bool|null $basicConstraintsValid BasicConstraintsValid indicates whether IsCA, MaxPathLen, and MaxPathLenZero are valid.
     *
     * @return $this
     */
    public function setBasicConstraintsValid($basicConstraintsValid)
    {
        $this->container['basicConstraintsValid'] = $basicConstraintsValid;

        return $this;
    }

    /**
     * Gets cRLDistributionPoints
     *
     * @return string[]|null
     */
    public function getCRLDistributionPoints()
    {
        return $this->container['cRLDistributionPoints'];
    }

    /**
     * Sets cRLDistributionPoints
     *
     * @param string[]|null $cRLDistributionPoints CRL Distribution Points
     *
     * @return $this
     */
    public function setCRLDistributionPoints($cRLDistributionPoints)
    {
        $this->container['cRLDistributionPoints'] = $cRLDistributionPoints;

        return $this;
    }

    /**
     * Gets dNSNames
     *
     * @return string[]|null
     */
    public function getDNSNames()
    {
        return $this->container['dNSNames'];
    }

    /**
     * Sets dNSNames
     *
     * @param string[]|null $dNSNames Subject Alternate Name values. (Note that these values may not be valid if invalid values were contained within a parsed certificate. For example, an element of DNSNames may not be a valid DNS domain name.)
     *
     * @return $this
     */
    public function setDNSNames($dNSNames)
    {
        $this->container['dNSNames'] = $dNSNames;

        return $this;
    }

    /**
     * Gets emailAddresses
     *
     * @return string[]|null
     */
    public function getEmailAddresses()
    {
        return $this->container['emailAddresses'];
    }

    /**
     * Sets emailAddresses
     *
     * @param string[]|null $emailAddresses email addresses
     *
     * @return $this
     */
    public function setEmailAddresses($emailAddresses)
    {
        $this->container['emailAddresses'] = $emailAddresses;

        return $this;
    }

    /**
     * Gets excludedDNSDomains
     *
     * @return string[]|null
     */
    public function getExcludedDNSDomains()
    {
        return $this->container['excludedDNSDomains'];
    }

    /**
     * Sets excludedDNSDomains
     *
     * @param string[]|null $excludedDNSDomains excluded DNS domains
     *
     * @return $this
     */
    public function setExcludedDNSDomains($excludedDNSDomains)
    {
        $this->container['excludedDNSDomains'] = $excludedDNSDomains;

        return $this;
    }

    /**
     * Gets excludedEmailAddresses
     *
     * @return string[]|null
     */
    public function getExcludedEmailAddresses()
    {
        return $this->container['excludedEmailAddresses'];
    }

    /**
     * Sets excludedEmailAddresses
     *
     * @param string[]|null $excludedEmailAddresses excluded email addresses
     *
     * @return $this
     */
    public function setExcludedEmailAddresses($excludedEmailAddresses)
    {
        $this->container['excludedEmailAddresses'] = $excludedEmailAddresses;

        return $this;
    }

    /**
     * Gets excludedIPRanges
     *
     * @return \Ory\Hydra\Client\Model\IPNet[]|null
     */
    public function getExcludedIPRanges()
    {
        return $this->container['excludedIPRanges'];
    }

    /**
     * Sets excludedIPRanges
     *
     * @param \Ory\Hydra\Client\Model\IPNet[]|null $excludedIPRanges excluded IP ranges
     *
     * @return $this
     */
    public function setExcludedIPRanges($excludedIPRanges)
    {
        $this->container['excludedIPRanges'] = $excludedIPRanges;

        return $this;
    }

    /**
     * Gets excludedURIDomains
     *
     * @return string[]|null
     */
    public function getExcludedURIDomains()
    {
        return $this->container['excludedURIDomains'];
    }

    /**
     * Sets excludedURIDomains
     *
     * @param string[]|null $excludedURIDomains excluded URI domains
     *
     * @return $this
     */
    public function setExcludedURIDomains($excludedURIDomains)
    {
        $this->container['excludedURIDomains'] = $excludedURIDomains;

        return $this;
    }

    /**
     * Gets extKeyUsage
     *
     * @return int[]|null
     */
    public function getExtKeyUsage()
    {
        return $this->container['extKeyUsage'];
    }

    /**
     * Sets extKeyUsage
     *
     * @param int[]|null $extKeyUsage ext key usage
     *
     * @return $this
     */
    public function setExtKeyUsage($extKeyUsage)
    {
        $this->container['extKeyUsage'] = $extKeyUsage;

        return $this;
    }

    /**
     * Gets extensions
     *
     * @return \Ory\Hydra\Client\Model\Extension[]|null
     */
    public function getExtensions()
    {
        return $this->container['extensions'];
    }

    /**
     * Sets extensions
     *
     * @param \Ory\Hydra\Client\Model\Extension[]|null $extensions Extensions contains raw X.509 extensions. When parsing certificates, this can be used to extract non-critical extensions that are not parsed by this package. When marshaling certificates, the Extensions field is ignored, see ExtraExtensions.
     *
     * @return $this
     */
    public function setExtensions($extensions)
    {
        $this->container['extensions'] = $extensions;

        return $this;
    }

    /**
     * Gets extraExtensions
     *
     * @return \Ory\Hydra\Client\Model\Extension[]|null
     */
    public function getExtraExtensions()
    {
        return $this->container['extraExtensions'];
    }

    /**
     * Sets extraExtensions
     *
     * @param \Ory\Hydra\Client\Model\Extension[]|null $extraExtensions ExtraExtensions contains extensions to be copied, raw, into any marshaled certificates. Values override any extensions that would otherwise be produced based on the other fields. The ExtraExtensions field is not populated when parsing certificates, see Extensions.
     *
     * @return $this
     */
    public function setExtraExtensions($extraExtensions)
    {
        $this->container['extraExtensions'] = $extraExtensions;

        return $this;
    }

    /**
     * Gets iPAddresses
     *
     * @return \Ory\Hydra\Client\Model\array[]|null
     */
    public function getIPAddresses()
    {
        return $this->container['iPAddresses'];
    }

    /**
     * Sets iPAddresses
     *
     * @param \Ory\Hydra\Client\Model\array[]|null $iPAddresses IP addresses
     *
     * @return $this
     */
    public function setIPAddresses($iPAddresses)
    {
        $this->container['iPAddresses'] = $iPAddresses;

        return $this;
    }

    /**
     * Gets isCA
     *
     * @return bool|null
     */
    public function getIsCA()
    {
        return $this->container['isCA'];
    }

    /**
     * Sets isCA
     *
     * @param bool|null $isCA is c a
     *
     * @return $this
     */
    public function setIsCA($isCA)
    {
        $this->container['isCA'] = $isCA;

        return $this;
    }

    /**
     * Gets issuer
     *
     * @return \Ory\Hydra\Client\Model\Name|null
     */
    public function getIssuer()
    {
        return $this->container['issuer'];
    }

    /**
     * Sets issuer
     *
     * @param \Ory\Hydra\Client\Model\Name|null $issuer issuer
     *
     * @return $this
     */
    public function setIssuer($issuer)
    {
        $this->container['issuer'] = $issuer;

        return $this;
    }

    /**
     * Gets issuingCertificateURL
     *
     * @return string[]|null
     */
    public function getIssuingCertificateURL()
    {
        return $this->container['issuingCertificateURL'];
    }

    /**
     * Sets issuingCertificateURL
     *
     * @param string[]|null $issuingCertificateURL issuing certificate URL
     *
     * @return $this
     */
    public function setIssuingCertificateURL($issuingCertificateURL)
    {
        $this->container['issuingCertificateURL'] = $issuingCertificateURL;

        return $this;
    }

    /**
     * Gets keyUsage
     *
     * @return int|null
     */
    public function getKeyUsage()
    {
        return $this->container['keyUsage'];
    }

    /**
     * Sets keyUsage
     *
     * @param int|null $keyUsage KeyUsage KeyUsage KeyUsage KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.
     *
     * @return $this
     */
    public function setKeyUsage($keyUsage)
    {
        $this->container['keyUsage'] = $keyUsage;

        return $this;
    }

    /**
     * Gets maxPathLen
     *
     * @return int|null
     */
    public function getMaxPathLen()
    {
        return $this->container['maxPathLen'];
    }

    /**
     * Sets maxPathLen
     *
     * @param int|null $maxPathLen MaxPathLen and MaxPathLenZero indicate the presence and value of the BasicConstraints' \"pathLenConstraint\".  When parsing a certificate, a positive non-zero MaxPathLen means that the field was specified, -1 means it was unset, and MaxPathLenZero being true mean that the field was explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false should be treated equivalent to -1 (unset).  When generating a certificate, an unset pathLenConstraint can be requested with either MaxPathLen == -1 or using the zero value for both MaxPathLen and MaxPathLenZero.
     *
     * @return $this
     */
    public function setMaxPathLen($maxPathLen)
    {
        $this->container['maxPathLen'] = $maxPathLen;

        return $this;
    }

    /**
     * Gets maxPathLenZero
     *
     * @return bool|null
     */
    public function getMaxPathLenZero()
    {
        return $this->container['maxPathLenZero'];
    }

    /**
     * Sets maxPathLenZero
     *
     * @param bool|null $maxPathLenZero MaxPathLenZero indicates that BasicConstraintsValid==true and MaxPathLen==0 should be interpreted as an actual maximum path length of zero. Otherwise, that combination is interpreted as MaxPathLen not being set.
     *
     * @return $this
     */
    public function setMaxPathLenZero($maxPathLenZero)
    {
        $this->container['maxPathLenZero'] = $maxPathLenZero;

        return $this;
    }

    /**
     * Gets notBefore
     *
     * @return \DateTime|null
     */
    public function getNotBefore()
    {
        return $this->container['notBefore'];
    }

    /**
     * Sets notBefore
     *
     * @param \DateTime|null $notBefore not before Format: date-time Format: date-time Format: date-time
     *
     * @return $this
     */
    public function setNotBefore($notBefore)
    {
        $this->container['notBefore'] = $notBefore;

        return $this;
    }

    /**
     * Gets oCSPServer
     *
     * @return string[]|null
     */
    public function getOCSPServer()
    {
        return $this->container['oCSPServer'];
    }

    /**
     * Sets oCSPServer
     *
     * @param string[]|null $oCSPServer RFC 5280, 4.2.2.1 (Authority Information Access)
     *
     * @return $this
     */
    public function setOCSPServer($oCSPServer)
    {
        $this->container['oCSPServer'] = $oCSPServer;

        return $this;
    }

    /**
     * Gets permittedDNSDomains
     *
     * @return string[]|null
     */
    public function getPermittedDNSDomains()
    {
        return $this->container['permittedDNSDomains'];
    }

    /**
     * Sets permittedDNSDomains
     *
     * @param string[]|null $permittedDNSDomains permitted DNS domains
     *
     * @return $this
     */
    public function setPermittedDNSDomains($permittedDNSDomains)
    {
        $this->container['permittedDNSDomains'] = $permittedDNSDomains;

        return $this;
    }

    /**
     * Gets permittedDNSDomainsCritical
     *
     * @return bool|null
     */
    public function getPermittedDNSDomainsCritical()
    {
        return $this->container['permittedDNSDomainsCritical'];
    }

    /**
     * Sets permittedDNSDomainsCritical
     *
     * @param bool|null $permittedDNSDomainsCritical Name constraints
     *
     * @return $this
     */
    public function setPermittedDNSDomainsCritical($permittedDNSDomainsCritical)
    {
        $this->container['permittedDNSDomainsCritical'] = $permittedDNSDomainsCritical;

        return $this;
    }

    /**
     * Gets permittedEmailAddresses
     *
     * @return string[]|null
     */
    public function getPermittedEmailAddresses()
    {
        return $this->container['permittedEmailAddresses'];
    }

    /**
     * Sets permittedEmailAddresses
     *
     * @param string[]|null $permittedEmailAddresses permitted email addresses
     *
     * @return $this
     */
    public function setPermittedEmailAddresses($permittedEmailAddresses)
    {
        $this->container['permittedEmailAddresses'] = $permittedEmailAddresses;

        return $this;
    }

    /**
     * Gets permittedIPRanges
     *
     * @return \Ory\Hydra\Client\Model\IPNet[]|null
     */
    public function getPermittedIPRanges()
    {
        return $this->container['permittedIPRanges'];
    }

    /**
     * Sets permittedIPRanges
     *
     * @param \Ory\Hydra\Client\Model\IPNet[]|null $permittedIPRanges permitted IP ranges
     *
     * @return $this
     */
    public function setPermittedIPRanges($permittedIPRanges)
    {
        $this->container['permittedIPRanges'] = $permittedIPRanges;

        return $this;
    }

    /**
     * Gets permittedURIDomains
     *
     * @return string[]|null
     */
    public function getPermittedURIDomains()
    {
        return $this->container['permittedURIDomains'];
    }

    /**
     * Sets permittedURIDomains
     *
     * @param string[]|null $permittedURIDomains permitted URI domains
     *
     * @return $this
     */
    public function setPermittedURIDomains($permittedURIDomains)
    {
        $this->container['permittedURIDomains'] = $permittedURIDomains;

        return $this;
    }

    /**
     * Gets policyIdentifiers
     *
     * @return \Ory\Hydra\Client\Model\array[]|null
     */
    public function getPolicyIdentifiers()
    {
        return $this->container['policyIdentifiers'];
    }

    /**
     * Sets policyIdentifiers
     *
     * @param \Ory\Hydra\Client\Model\array[]|null $policyIdentifiers policy identifiers
     *
     * @return $this
     */
    public function setPolicyIdentifiers($policyIdentifiers)
    {
        $this->container['policyIdentifiers'] = $policyIdentifiers;

        return $this;
    }

    /**
     * Gets publicKey
     *
     * @return object|null
     */
    public function getPublicKey()
    {
        return $this->container['publicKey'];
    }

    /**
     * Sets publicKey
     *
     * @param object|null $publicKey public key
     *
     * @return $this
     */
    public function setPublicKey($publicKey)
    {
        $this->container['publicKey'] = $publicKey;

        return $this;
    }

    /**
     * Gets publicKeyAlgorithm
     *
     * @return int|null
     */
    public function getPublicKeyAlgorithm()
    {
        return $this->container['publicKeyAlgorithm'];
    }

    /**
     * Sets publicKeyAlgorithm
     *
     * @param int|null $publicKeyAlgorithm PublicKeyAlgorithm PublicKeyAlgorithm PublicKeyAlgorithm public key algorithm
     *
     * @return $this
     */
    public function setPublicKeyAlgorithm($publicKeyAlgorithm)
    {
        $this->container['publicKeyAlgorithm'] = $publicKeyAlgorithm;

        return $this;
    }

    /**
     * Gets raw
     *
     * @return int[]|null
     */
    public function getRaw()
    {
        return $this->container['raw'];
    }

    /**
     * Sets raw
     *
     * @param int[]|null $raw raw
     *
     * @return $this
     */
    public function setRaw($raw)
    {
        $this->container['raw'] = $raw;

        return $this;
    }

    /**
     * Gets rawIssuer
     *
     * @return int[]|null
     */
    public function getRawIssuer()
    {
        return $this->container['rawIssuer'];
    }

    /**
     * Sets rawIssuer
     *
     * @param int[]|null $rawIssuer raw issuer
     *
     * @return $this
     */
    public function setRawIssuer($rawIssuer)
    {
        $this->container['rawIssuer'] = $rawIssuer;

        return $this;
    }

    /**
     * Gets rawSubject
     *
     * @return int[]|null
     */
    public function getRawSubject()
    {
        return $this->container['rawSubject'];
    }

    /**
     * Sets rawSubject
     *
     * @param int[]|null $rawSubject raw subject
     *
     * @return $this
     */
    public function setRawSubject($rawSubject)
    {
        $this->container['rawSubject'] = $rawSubject;

        return $this;
    }

    /**
     * Gets rawSubjectPublicKeyInfo
     *
     * @return int[]|null
     */
    public function getRawSubjectPublicKeyInfo()
    {
        return $this->container['rawSubjectPublicKeyInfo'];
    }

    /**
     * Sets rawSubjectPublicKeyInfo
     *
     * @param int[]|null $rawSubjectPublicKeyInfo raw subject public key info
     *
     * @return $this
     */
    public function setRawSubjectPublicKeyInfo($rawSubjectPublicKeyInfo)
    {
        $this->container['rawSubjectPublicKeyInfo'] = $rawSubjectPublicKeyInfo;

        return $this;
    }

    /**
     * Gets rawTBSCertificate
     *
     * @return int[]|null
     */
    public function getRawTBSCertificate()
    {
        return $this->container['rawTBSCertificate'];
    }

    /**
     * Sets rawTBSCertificate
     *
     * @param int[]|null $rawTBSCertificate raw t b s certificate
     *
     * @return $this
     */
    public function setRawTBSCertificate($rawTBSCertificate)
    {
        $this->container['rawTBSCertificate'] = $rawTBSCertificate;

        return $this;
    }

    /**
     * Gets serialNumber
     *
     * @return object|null
     */
    public function getSerialNumber()
    {
        return $this->container['serialNumber'];
    }

    /**
     * Sets serialNumber
     *
     * @param object|null $serialNumber Operations always take pointer arguments (*Int) rather than Int values, and each unique Int value requires its own unique *Int pointer. To \"copy\" an Int value, an existing (or newly allocated) Int must be set to a new value using the Int.Set method; shallow copies of Ints are not supported and may lead to errors.
     *
     * @return $this
     */
    public function setSerialNumber($serialNumber)
    {
        $this->container['serialNumber'] = $serialNumber;

        return $this;
    }

    /**
     * Gets signature
     *
     * @return int[]|null
     */
    public function getSignature()
    {
        return $this->container['signature'];
    }

    /**
     * Sets signature
     *
     * @param int[]|null $signature signature
     *
     * @return $this
     */
    public function setSignature($signature)
    {
        $this->container['signature'] = $signature;

        return $this;
    }

    /**
     * Gets signatureAlgorithm
     *
     * @return int|null
     */
    public function getSignatureAlgorithm()
    {
        return $this->container['signatureAlgorithm'];
    }

    /**
     * Sets signatureAlgorithm
     *
     * @param int|null $signatureAlgorithm SignatureAlgorithm SignatureAlgorithm SignatureAlgorithm signature algorithm
     *
     * @return $this
     */
    public function setSignatureAlgorithm($signatureAlgorithm)
    {
        $this->container['signatureAlgorithm'] = $signatureAlgorithm;

        return $this;
    }

    /**
     * Gets subject
     *
     * @return \Ory\Hydra\Client\Model\Name|null
     */
    public function getSubject()
    {
        return $this->container['subject'];
    }

    /**
     * Sets subject
     *
     * @param \Ory\Hydra\Client\Model\Name|null $subject subject
     *
     * @return $this
     */
    public function setSubject($subject)
    {
        $this->container['subject'] = $subject;

        return $this;
    }

    /**
     * Gets subjectKeyId
     *
     * @return int[]|null
     */
    public function getSubjectKeyId()
    {
        return $this->container['subjectKeyId'];
    }

    /**
     * Sets subjectKeyId
     *
     * @param int[]|null $subjectKeyId subject key Id
     *
     * @return $this
     */
    public function setSubjectKeyId($subjectKeyId)
    {
        $this->container['subjectKeyId'] = $subjectKeyId;

        return $this;
    }

    /**
     * Gets uRIs
     *
     * @return \Ory\Hydra\Client\Model\URL[]|null
     */
    public function getURIs()
    {
        return $this->container['uRIs'];
    }

    /**
     * Sets uRIs
     *
     * @param \Ory\Hydra\Client\Model\URL[]|null $uRIs u r is
     *
     * @return $this
     */
    public function setURIs($uRIs)
    {
        $this->container['uRIs'] = $uRIs;

        return $this;
    }

    /**
     * Gets unhandledCriticalExtensions
     *
     * @return \Ory\Hydra\Client\Model\array[]|null
     */
    public function getUnhandledCriticalExtensions()
    {
        return $this->container['unhandledCriticalExtensions'];
    }

    /**
     * Sets unhandledCriticalExtensions
     *
     * @param \Ory\Hydra\Client\Model\array[]|null $unhandledCriticalExtensions UnhandledCriticalExtensions contains a list of extension IDs that were not (fully) processed when parsing. Verify will fail if this slice is non-empty, unless verification is delegated to an OS library which understands all the critical extensions.  Users can access these extensions using Extensions and can remove elements from this slice if they believe that they have been handled.
     *
     * @return $this
     */
    public function setUnhandledCriticalExtensions($unhandledCriticalExtensions)
    {
        $this->container['unhandledCriticalExtensions'] = $unhandledCriticalExtensions;

        return $this;
    }

    /**
     * Gets unknownExtKeyUsage
     *
     * @return \Ory\Hydra\Client\Model\array[]|null
     */
    public function getUnknownExtKeyUsage()
    {
        return $this->container['unknownExtKeyUsage'];
    }

    /**
     * Sets unknownExtKeyUsage
     *
     * @param \Ory\Hydra\Client\Model\array[]|null $unknownExtKeyUsage unknown ext key usage
     *
     * @return $this
     */
    public function setUnknownExtKeyUsage($unknownExtKeyUsage)
    {
        $this->container['unknownExtKeyUsage'] = $unknownExtKeyUsage;

        return $this;
    }

    /**
     * Gets version
     *
     * @return int|null
     */
    public function getVersion()
    {
        return $this->container['version'];
    }

    /**
     * Sets version
     *
     * @param int|null $version version
     *
     * @return $this
     */
    public function setVersion($version)
    {
        $this->container['version'] = $version;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


